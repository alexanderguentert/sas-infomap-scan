# -*- coding: utf-8 -*-
"""
Created on Mon Jun 29 17:10:41 2020

@author: sszgrm
"""

# TODOS
# - Verbesserung anstatt "Path too long" das File kopieren und lokal entzippen
# --- Beispiel in: J:/Datenmanagement/4_DWH/2_Qualitätssicherung/1_BVS6/ 

import zipfile
import re
import os
import pandas as pd
import numpy as np
import datetime
import json
import shutil

pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows', None)

# unzip one file from a zip archive to a given directory
def proj_unzip(zip_path, extract_filename, extract_path):
    
    if not(os.path.exists(zip_path)):
        # Some filenames are not only too long for python to read them,
        # they're even too long to be copied to another directory
        print("WARNING: Absolute filename too long for OS to recognize file.")
        print("-> Move or rename file manually")
        print("File: " + zip_path)
        NamesTooLongOS.append(zip_path)

    else:
        if len(zip_path)>255:
        
            tmp_file = extract_path + "/tmp.egp"
            
            if not(os.path.exists(extract_path)):
                os.makedirs(extract_path)
            # ZipFile does not support long paths
            print("WARNING: Path too long for python to extract: " + zip_path)
            print("Copying file to local file " + tmp_file)
            shutil.copy(zip_path, tmp_file)
            zip_path_final = tmp_file 
        else:
            zip_path_final = zip_path
            
        try:
            with zipfile.ZipFile(zip_path_final, 'r') as zip_ref:
                zip_ref.extract(extract_filename, path=extract_path)
                return extract_path + "/" + extract_filename
        except Exception: 
            print('ERROR: Not unzippable: ' + zip_path_final)
            NotUnzippable.append(zip_path_final)
            return

# Python program to convert a list to string
# Function to convert  
def listToString(s): 
    
    # initialize an empty string
    str1 = "" 
    
    # traverse in the string  
    for ele in s: 
        str1 += ele  
    
    # return string  
    return str1 


# Function to extract variables from filter block
def extract_filter_vars(string):

  pattern = '\\(+(.+?)(;|IS MISSING|=|CONTAINS|LIKE|AND|>|<)+'
  
  v0 = re.findall(pattern, string, re.IGNORECASE)
  v1 = [x[0].strip() for x in v0]
  v2 = [re.sub('&lt', '', x) for x in v1]
  v3 = [re.sub('&gt', '', x).strip() for x in v2]
  
  v = list(set(v3))
  
  return v 

  
# read project.xml as a textfile an find infomap codeblocks

# libname _egimle sasioime
# 	 mappath="/InformationMaps/Bevoelkerung/BVS Wegzug int."
# 	 aggregate=yes
# 	 metacredentials=no
# 	 PRESERVE_MAP_NAMES=YES
# 	 %SetDisplayOrder;
# /* NOTE: when using this LIBNAME statement in a batch environment,  */
# /* you might need to add metadata host and credentials information. */
#
# data WORK.WEG (label='Ausgewählte Daten von BVS Wegzug int.');
# 	sysecho "Extrahieren von Daten aus der Information Map";
# 	length 
# 		FilterJahr 8
# 		...
# 		;
# 	label 
# 		FilterJahr="Jahresfilter"  /* Jahresfilter */
# 		...
# 		;
# 	
# 	set _egimle."BVS Wegzug int."n 
# 		(keep=
# 			FilterJahr
# 			StichtagDatJahr
# 			AnzWezuWir
# 			HerkunftSort
# 			ExportVersionCd 
# 		 /* default EXPCOLUMNLEN is 32 */ 
# 		 filter=((FilterJahr &gt;= 1) AND NOT (ExportVersionCd = "A")) 
# 		 
# 		 );
# 	
# run;
#
# /* clear the libname when complete */
# libname _egimle clear;

# the function extracts the variable names by finding the libname block
# and within that finding the keep statement
# this works quite well, as the code is almost always generated by seg
# and not modified by the user

def extract_infomap_code(code_file, file_encoding):

    infomap_list_code = []
    keep_list = []
    modby_list = []
    is_im_block = False
    is_keep_block = False
    i=0
    
    with open(code_file, encoding=file_encoding) as f:
        content = f.readlines()
        im_list = {}

        # find people that modified the code
        for x in content:
            line = x.strip()
            modby_search = re.search('<ModifiedBy>(.+?)<', line, re.IGNORECASE)
            
            if modby_search:
                modby_person = modby_search.group(1)
                modby_list.append(modby_person)

        # Remove duplicates by converting to a dictionary an back to a list
        modby_list = list(dict.fromkeys(modby_list))
        # Convert list to comma separated string
        modby_people = ", ".join(modby_list)

        # find used variables
        for x in content:
            line = x.strip()
            i = i + 1

            
            if line == "libname _egimle sasioime": 
                # code block with libname starting
                im_list = {}
                keep_list = []
                is_im_block = True
                im_list["modified_by"] = modby_people
                
            if line == "libname _egimle clear;": 
                # end of information map libname assignement
                if not "variables_keep_or_filter" in im_list:
                     # No variables could be extracted, that is not good
                     im_list["variables_keep_or_filter"] = ["ERROR no variables found"]
                infomap_list_code.append(im_list)
                is_keep_block = False
                is_im_block = False
            
            if is_im_block == True:
                mappath_search = re.search('mappath="(.*)"', line, re.IGNORECASE)
                if mappath_search:
                    # extract infomap name as the text behind the last slash
                    im_list["infomap_name"] = mappath_search.group(1).rsplit('/', 1)[-1]
                        
                if is_keep_block == True:
                    # check if the block ends either with a filter or the closing bracket and semicolon
                    if line[-2:] == ");" or line[0:8] == "filter=(":
                        # end of code block with keep variable definitions
                        im_list["variables_keep_or_filter"] = keep_list
                        is_keep_block = False
                    else:
                        # check if the line is not empty, is not a comment and does not use macros
                        if line and line[0:2] != "/*" and line[0:2] != "*/" and line[0:1] != "%" and line[0:1] != "&":
                            # add this variable definition to the list
                            keep_list.append(line)
                    
                if line[0:6] == "(keep=":
                    # code block with keep statement starting
                    # the following lines are recognized as variable names
                    keep_list = []
                    is_keep_block = True               
                    
                if line[0:8] == "filter=(":
                    # also seperately scan the filter statement, as they're not necessarily
                    # included in the keep statement
                    filter_list = extract_filter_vars(line)
                    for filter_var in filter_list:
                        keep_list.append(filter_var)
 
    return infomap_list_code

# Read configuration
with open('config.json', 'r', encoding="utf-8") as f:
    config = json.load(f)
temp_path = config['temp_path']
path_ignore = config['path_ignore']
path_list = config['path_list'] 
write_to_excel = config['write_to_excel']  

# uncomment this block to hardcode configuration items
# write_to_excel = True
# temp_path = "H:/Daten/Project/Desktop-2020/SampleSEG"
# path_ignore = ["/archiv/", "/_archiv/", "/Archiv/", "/_Archiv/", "/archive/",
#                "/Archive", "/alt/", "/Alt/", "/Archiv_nicht-löschen/",
#                "/00_Archiv/", "/0_Archiv/", "/9_Archiv/", "/X_Archiv/",
#                "/99_Alte_Anfrage_vor_InfoDesk/"]
# path_list = ["P:/Hotellerie"]

# uncomment this block to set the config data and write them back to a file 
# config = {}
# config['temp_path'] = temp_path
# config['path_ignore'] = path_ignore
# config['path_list'] = path_list
# config['write_to_excel'] = write_to_excel
# with open('config.json', 'w') as f:
#     json.dump(config, f, sort_keys=True, indent=4)

temp_unzip_path = temp_path + "/tempunzip"
proj_filename = "project.xml"
excel_out = temp_path + "/report.xlsx"
csv_out = temp_path + "/infomap-var-list.csv"

now = datetime.datetime.now()
print ("Start walking directories: " + now.strftime("%Y-%m-%d %H:%M:%S"))

list_seg = []
list_sas = []

for scan_path in path_list: 
    print("Scanning: " + scan_path)
    
    # traverse root directory, and list directories as dirs and files as files
    for root, dirs, files in os.walk(scan_path):
        for file in files:
            if file.endswith(".egp"):
                seg_path = os.path.join(root, file).replace('\\', '/')
                
                # check if path contains patterns like "archived" or "old" and ignore them
                to_ignore = any(x in seg_path for x in path_ignore) 
                if to_ignore==False:
                    list_seg.append(seg_path)
    
            if file.endswith(".sas"):
                sas_path = os.path.join(root, file).replace('\\', '/')
                
                # check if path contains patterns like "archived" or "old" and ignore them
                to_ignore = any(x in sas_path for x in path_ignore) 
                if to_ignore==False:
                    list_sas.append(sas_path)

df_list_seg = pd.DataFrame(list_seg, columns = ['seg_path'])

df_list_sas = pd.DataFrame(list_sas, columns = ['sas_path'])

NotUnzippable = []
NamesTooLongOS = []

if write_to_excel:
    with pd.ExcelWriter(excel_out, engine="openpyxl", mode='w') as writer:
        df_list_seg.to_excel(writer, sheet_name='SEG-Projects')
        
    with pd.ExcelWriter(excel_out, engine="openpyxl", mode='a') as writer:
        df_list_sas.to_excel(writer, sheet_name='SAS-Code-Files')


now = datetime.datetime.now()
print ("Start extracting informationmaps: " + now.strftime("%Y-%m-%d %H:%M:%S"))

df_im_code = pd.DataFrame()

# loop through all the SAS Enterprise Guide files
for index, row in df_list_seg.iterrows():
    # unzip the project.xml file from the egp-file (which is a zip-file)
    proj_fullpath = proj_unzip(row["seg_path"], proj_filename, temp_unzip_path)

    if proj_fullpath:
        # find alle informationmaps in the code element of project.xml
        im_list_code = extract_infomap_code(proj_fullpath, "utf16")
        if im_list_code:
            # add the filename and store in a dataframe
            df_list_code = pd.DataFrame(im_list_code)
            df_list_code['filename']=row["seg_path"].replace('/', '\\')
            
            aufgabenr_search = re.search('/(\d{4}-\d{2})_', row["seg_path"], re.IGNORECASE)
            
            if aufgabenr_search:
                aufgabenr = aufgabenr_search.group(1)
                df_list_code['aufgabe_nr']=aufgabenr
            
            df_im_code = df_im_code.append(df_list_code, ignore_index = True)

# loop through all the SAS code files
for index, row in df_list_sas.iterrows():
   # find alle informationmaps in the code element of project.xml
    im_list_code = extract_infomap_code(row["sas_path"], "latin-1")
    if im_list_code:
        # add the filename and store in a dataframe
        df_list_code = pd.DataFrame(im_list_code)
        df_list_code['filename']=row["sas_path"].replace('/', '\\')
        df_im_code = df_im_code.append(df_list_code, ignore_index = True)

if df_im_code.empty==False:
    # transpose the variables column containing a list of variables to a new row variables
    lst_col = 'variables_keep_or_filter'
    df_im_transv = pd.DataFrame({
          col:np.repeat(df_im_code[col].values, df_im_code[lst_col].str.len())
          for col in df_im_code.columns.drop(lst_col)}
        ).assign(**{lst_col:np.concatenate(df_im_code[lst_col].values)})[df_im_code.columns]
 
    df_im_transv = df_im_transv.drop_duplicates()
    
    if write_to_excel:
        # append-mode to create a new sheet in the existing excel file
        with pd.ExcelWriter(excel_out, engine="openpyxl", mode='a') as writer:
            df_im_transv.to_excel(writer, sheet_name='Code')
        
    df_im_transv.to_csv (csv_out, index = False, header=True)
 
pd.DataFrame(NotUnzippable, columns = ["path"]).to_excel(temp_path + "/notunzippable.xlsx")
pd.DataFrame(NamesTooLongOS, columns = ["path"]).to_excel(temp_path + "/NamesTooLongOS.xlsx")
now = datetime.datetime.now()
print ("Stop: " + now.strftime("%Y-%m-%d %H:%M:%S"))
